<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.3 ./Mecha.glb --shadows
-->

<script lang="ts">
  import { onDestroy } from "svelte";
  import { Group } from "three";
  import { T, forwardEventHandlers } from "@threlte/core";
  import { useGltf, useGltfAnimations } from "@threlte/extras";
  import { idle, idlePose, run, respawn, idleReady } from "../animationState";

  export const ref = new Group();

  let currentAnimation = "Idle_Base";
  let isTransitioning = false;

  const gltf = useGltf("/models/Mecha.glb");
  export const { actions, mixer } = useGltfAnimations(gltf, ref);

  // Log position and rotation periodically
  let logInterval: number;

  $: if (ref) {
    if (logInterval) clearInterval(logInterval);

    logInterval = setInterval(() => {
      console.log("3D Model Position:", {
        x: ref.position.x.toFixed(3),
        y: ref.position.y.toFixed(3),
        z: ref.position.z.toFixed(3),
      });
      console.log("3D Model Rotation:", {
        x: ref.rotation.x.toFixed(3),
        y: ref.rotation.y.toFixed(3),
        z: ref.rotation.z.toFixed(3),
      });
      console.log("3D Model Scale:", {
        x: ref.scale.x.toFixed(3),
        y: ref.scale.y.toFixed(3),
        z: ref.scale.z.toFixed(3),
      });
      console.log("---");
    }, 2000); // Log every 2 seconds
  }

  // Play current animation when it changes
  $: if ($actions[currentAnimation] && !isTransitioning) {
    $actions[currentAnimation]?.play();
  }

  const component = forwardEventHandlers();

  function transitionTo(nextAnimation: string, duration = 0.5) {
    if (nextAnimation === currentAnimation || isTransitioning) return;

    isTransitioning = true;
    const currentAnim = $actions[currentAnimation];
    const nextAnim = $actions[nextAnimation];

    if (!nextAnim) {
      isTransitioning = false;
      return;
    }

    // Stop all other animations first
    Object.keys($actions).forEach((key) => {
      if (key !== nextAnimation) {
        $actions[key]?.stop();
      }
    });

    nextAnim.reset().play();

    // Special handling for Respawn animation
    if (nextAnimation === "Respawn") {
      // Set the animation to play only once (not loop)
      nextAnim.setLoop(2201, 1); // LoopOnce = 2201
      nextAnim.clampWhenFinished = true;

      // Listen for animation finished event
      const onFinished = () => {
        // After Respawn finishes, transition to IdleReady
        setTimeout(() => {
          // Import setActiveAnimation dynamically to avoid circular imports
          import("../animationState").then(({ setActiveAnimation }) => {
            setActiveAnimation("idleReady");
          });
        }, 100);

        // Remove the event listener
        mixer.removeEventListener("finished", onFinished);
      };

      mixer.addEventListener("finished", onFinished);
    }

    // Special handling for IdleReady animation
    if (nextAnimation === "IdleReady") {
      // Set the animation to play only once (not loop)
      nextAnim.setLoop(2201, 1); // LoopOnce = 2201
      nextAnim.clampWhenFinished = true;

      // Listen for animation finished event
      const onIdleReadyFinished = () => {
        // After IdleReady finishes, transition to Idle
        setTimeout(() => {
          // Import setActiveAnimation dynamically to avoid circular imports
          import("../animationState").then(({ setActiveAnimation }) => {
            setActiveAnimation("idle");
          });
        }, 100);

        // Remove the event listener
        mixer.removeEventListener("finished", onIdleReadyFinished);
      };

      mixer.addEventListener("finished", onIdleReadyFinished);
    }

    if (currentAnim && currentAnim !== nextAnim) {
      currentAnim.crossFadeTo(nextAnim, duration, false);

      // Wait for transition to complete
      setTimeout(() => {
        currentAnimation = nextAnimation;
        isTransitioning = false;
      }, duration * 1000);
    } else {
      currentAnimation = nextAnimation;
      isTransitioning = false;
    }
  }

  // Animation state subscriptions
  const subIdle = idle.subscribe((value) => {
    if (value) {
      transitionTo("Idle_Base", 0.3);
    }
  });

  const subIdlePose = idlePose.subscribe((value) => {
    if (value) {
      transitionTo("Idle_Variant2", 0.3);
    }
  });

  const subRun = run.subscribe((value) => {
    if (value) {
      transitionTo("Run_Haste", 0.3);
    }
  });

  const subChannel = respawn.subscribe((value) => {
    if (value) {
      transitionTo("Respawn", 0.3);
    }
  });

  const subIdleReady = idleReady.subscribe((value) => {
    if (value) {
      transitionTo("IdleReady", 0.3);
    }
  });

  onDestroy(() => {
    subIdle();
    subRun();
    subIdlePose();
    subChannel();
    subIdleReady();

    // Clear logging interval
    if (logInterval) {
      clearInterval(logInterval);
    }
  });
</script>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component}>
  {#await gltf}
    <slot name="fallback" />
  {:then gltf}
    <T.Group name="Scene">
      <T.Group name="model" rotation={[-Math.PI, 0, 0]} scale={-0.025}>
        <T is={gltf.nodes.Root} />
        <T is={gltf.nodes.C_Buffbone_Glb_Layout_Loc} />
        <T is={gltf.nodes.C_Buffbone_Glb_Center_Loc} />
        <T is={gltf.nodes.Buffbone_Glb_Ground_Loc} />
        <T is={gltf.nodes.C_Buffbone_Glb_Overhead_Loc} />
        <T is={gltf.nodes.Buffbone_Glb_Channel_Loc} />
        <T is={gltf.nodes.Buffbone_Glb_Weapon_1} />
        <T is={gltf.nodes.Buffbone_Cstm_Healthbar} />
        <T is={gltf.nodes.Photo} />
        <T.Group name="Mesh_0">
          <T.SkinnedMesh
            name="Mesh_0_1"
            castShadow
            receiveShadow
            geometry={gltf.nodes.Mesh_0_1.geometry}
            material={gltf.materials.Sett_Skin01_MAT}
            skeleton={gltf.nodes.Mesh_0_1.skeleton}
          />
          <!--  <T.SkinnedMesh
            name="Mesh_0_2"
            castShadow
            receiveShadow
            geometry={gltf.nodes.Mesh_0_2.geometry}
            material={gltf.materials.Joke}
            skeleton={gltf.nodes.Mesh_0_2.skeleton}
          /> -->
        </T.Group>
      </T.Group>
    </T.Group>
  {:catch error}
    <slot name="error" {error} />
  {/await}
  <slot {ref} />
</T>
