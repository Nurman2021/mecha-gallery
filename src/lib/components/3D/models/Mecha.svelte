<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.3 ./Mecha.glb --shadows
-->

<script lang="ts">
  import { onDestroy } from "svelte";
  import { Group } from "three";
  import { T, forwardEventHandlers } from "@threlte/core";
  import { useGltf, useGltfAnimations } from "@threlte/extras";
  import { idle, idlePose, run, channel } from "../animationState";

  export const ref = new Group();

  let currentAnimation = "Idle_Base";
  let isTransitioning = false;

  const gltf = useGltf("/models/Mecha.glb");
  export const { actions, mixer } = useGltfAnimations(gltf, ref);

  // Play current animation when it changes
  $: if ($actions[currentAnimation] && !isTransitioning) {
    $actions[currentAnimation]?.play();
  }

  const component = forwardEventHandlers();

  function transitionTo(nextAnimation: string, duration = 0.5) {
    if (nextAnimation === currentAnimation || isTransitioning) return;

    isTransitioning = true;
    const currentAnim = $actions[currentAnimation];
    const nextAnim = $actions[nextAnimation];

    if (!nextAnim) {
      isTransitioning = false;
      return;
    }

    // Stop all other animations first
    Object.keys($actions).forEach((key) => {
      if (key !== nextAnimation) {
        $actions[key]?.stop();
      }
    });

    nextAnim.reset().play();

    if (currentAnim && currentAnim !== nextAnim) {
      currentAnim.crossFadeTo(nextAnim, duration, false);

      // Wait for transition to complete
      setTimeout(() => {
        currentAnimation = nextAnimation;
        isTransitioning = false;
      }, duration * 1000);
    } else {
      currentAnimation = nextAnimation;
      isTransitioning = false;
    }
  }

  // Animation state subscriptions
  const subIdle = idle.subscribe((value) => {
    if (value) {
      transitionTo("Idle_Base", 0.3);
    }
  });

  const subIdlePose = idlePose.subscribe((value) => {
    if (value) {
      transitionTo("Idle_Variant2", 0.3);
    }
  });

  const subRun = run.subscribe((value) => {
    if (value) {
      transitionTo("Run_Haste", 0.3);
    }
  });

  const subChannel = channel.subscribe((value) => {
    if (value) {
      transitionTo("Channel", 0.3);
    }
  });

  onDestroy(() => {
    subIdle();
    subRun();
    subIdlePose();
    subChannel();
  });
</script>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component}>
  {#await gltf}
    <slot name="fallback" />
  {:then gltf}
    <T.Group name="Scene">
      <T.Group name="model" rotation={[-Math.PI, 0, 0]} scale={-0.025}>
        <T is={gltf.nodes.Root} />
        <T is={gltf.nodes.C_Buffbone_Glb_Layout_Loc} />
        <T is={gltf.nodes.C_Buffbone_Glb_Center_Loc} />
        <T is={gltf.nodes.Buffbone_Glb_Ground_Loc} />
        <T is={gltf.nodes.C_Buffbone_Glb_Overhead_Loc} />
        <T is={gltf.nodes.Buffbone_Glb_Channel_Loc} />
        <T is={gltf.nodes.Buffbone_Glb_Weapon_1} />
        <T is={gltf.nodes.Buffbone_Cstm_Healthbar} />
        <T is={gltf.nodes.Photo} />
        <T.Group name="Mesh_0">
          <T.SkinnedMesh
            name="Mesh_0_1"
            castShadow
            receiveShadow
            geometry={gltf.nodes.Mesh_0_1.geometry}
            material={gltf.materials.Sett_Skin01_MAT}
            skeleton={gltf.nodes.Mesh_0_1.skeleton}
          />
          <!--  <T.SkinnedMesh
            name="Mesh_0_2"
            castShadow
            receiveShadow
            geometry={gltf.nodes.Mesh_0_2.geometry}
            material={gltf.materials.Joke}
            skeleton={gltf.nodes.Mesh_0_2.skeleton}
          /> -->
        </T.Group>
      </T.Group>
    </T.Group>
  {:catch error}
    <slot name="error" {error} />
  {/await}
  <slot {ref} />
</T>
